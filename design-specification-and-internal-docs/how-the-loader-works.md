# How the loader works

You can see a description of how to run under different modes [here](https://app.gitbook.com/@chembl/s/chembl-loader/design-specification-and-internal-docs/running-loader#loading-modes-m-option).

### Modes 1-3

These check the data are suitable, and show what would be loaded if mode 4 was run on the input files. They do not make any changes to the database, and are good for validating the input files. 

### Mode 4

This actually loads the data. The loader will load to the DEP tables and the visible tables \(e.g. DEP\_ASSAY and ASSAY\) independently.

## Loader steps

After each step, the loader will print out a two tables of errors and warnings.

* `Types of Errors` is a summary table with a description of the error, a score for the error type, and a total number of counds.
* `ALL_PENALTY_SCORES` is a table of all errors for that loading step, one line per error. 

### Validating the files

The loader will check that the files in the directory match the regex patterns for valid files. It will expect to see the files named in  "[Input file structure and requirements](https://app.gitbook.com/@chembl/s/chembl-loader/~/drafts/-MkHBKwUYgvdHAMnL3Oh/untitled-10)". It will skip over temporary and log files that were generated by previous runs of the loader. It will also skip over README files, as well as the .DS\_STORE files that mark Mac directories. 

### Validating the headers

The loader will check the the headers for a file match the names described in the`input_files` dict in ldconfigs.py. If the headers names are illegal, or a mandatory header is missing, the loader will exit.

### Validating the data

The data are read in from the file to the dataframes described in  "\# HEADERS..." section of ldConfigs. A lot of the variables used here are drawn from globalvars.py. Depending on the column, a failure to match a dependency or pattern could be a low-priority warning, or it could force the loader to exit. 

<table>
  <thead>
    <tr>
      <th style="text-align:left">Column</th>
      <th style="text-align:left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:left">Header</td>
      <td style="text-align:left">Header string for this column in the input file. Used as the header for
        the dataframe</td>
    </tr>
    <tr>
      <td style="text-align:left">Datatype</td>
      <td style="text-align:left">First tuple element is the Oracle SQL datatype for the column in the ChEMBL
        database. Set as a variable in ldConfigs.py. E.g. dV1 = &quot;VARCHAR2(XYZ
        BYTE)&quot;.
        <br />Second tuple element is the size of the datatype.</td>
    </tr>
    <tr>
      <td style="text-align:left">Existence</td>
      <td style="text-align:left">First tuple element is the existence definition from the Config class
        in ldConfigs.py. E.g. e1 = must exist. e4 = must not exist.
        <br />Second tuple element is the error level to return when a record fails
        this rule.</td>
    </tr>
    <tr>
      <td style="text-align:left">Pattern</td>
      <td style="text-align:left">
        <p>First tuple element is the pattern function to use to check that values
          in this column are valid. This is imported from globalVars.py.</p>
        <p>Second tuple element is the error level to return when a record fails
          this rule.</p>
      </td>
    </tr>
    <tr>
      <td style="text-align:left">Dependency</td>
      <td style="text-align:left">
        <p>First tuple element is the dependency function to use for this column,
          which is imported from globalVars.py.</p>
        <p>Second tuple element is the error level to return when a record fails
          this rule.</p>
      </td>
    </tr>
    <tr>
      <td style="text-align:left">f</td>
      <td style="text-align:left">Usually set to f0, which is equal to the string &quot;zero&quot;</td>
    </tr>
    <tr>
      <td style="text-align:left">aSortOrder</td>
      <td style="text-align:left">aSortOrder determines the order in which column_id is assigned when tables
        are created, AND the order in which they are presented in the web app</td>
    </tr>
  </tbody>
</table>

**Other common loader issues**

* The file contains an empty column, e.g. because there is a tab at the end of each line. 
* A CIDX given in the SDFile does not appear in the compound\_records file.
* There is some form of characterset issue \(e.g. Windows encoding\) though running the files through dos2unix usually fixes that.

### Loading the data

### Configuration Overview

You can see full notes on how the loader is configured on the [loader configuration](https://app.gitbook.com/@chembl/s/chembl-loader/~/drafts/-MkD4-12NsOgEWuDeeE4/design-specification-and-internal-docs/loader-configuration) page.

**globalVars.py**

* globalVars.py has dependency \(gdXX\) and pattern \(gpXX\) functions that check if a field is valid.
  * Dependency functions check the contents of another column. E.g. "If a Title exists, there must also be a Year"
  * Pattern functions check the contents of a target column. E.g. "If there is a PubMed ID, it must match this regex for an expected PubMed ID".
* globalVars.py also defines filenames, headers and table names, which get referenced in ldConfigs.py

**ldConfigs.py**

* Imports patterns, dependencies, case format and filenames from globalVars.
* Defines expected structure of input file and additional constraints on the fields.
* Defines the load order of the files. Are they in the Primary group, the Secondary group or the Quaternary group
* Defines which keys are self-referenced keys, which must be owned by the same depositor SRC\_ID \(SRKeys dict\)
* Maps the name of a field in the DEP\_ tables to the name of a field in the main ChEMBL tables.

